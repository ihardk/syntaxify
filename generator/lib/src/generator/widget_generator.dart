import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import 'package:forge/src/models/ast_node.dart';
import 'package:forge/src/models/token_definition.dart';

/// Generates Flutter widget code following the Forge architecture:
/// - Widget receives tokens from AppTheme.of(context)
/// - Uses renderer pattern (tokens + spec)
/// - No hardcoded styling in widget
class WidgetGenerator {
  WidgetGenerator({
    this.version = '0.1.0',
  });

  final String version;
  final _formatter = DartFormatter();
  final _emitter = DartEmitter(useNullSafetySyntax: true);

  /// Generate widget code for a component
  String generate({
    required AstNode node,
    TokenDefinition? tokens,
  }) {
    // Strip "Meta" suffix from class name for output
    final componentName = node.className.replaceAll('Meta', '');
    final className = 'App$componentName';

    final library = Library(
      (b) => b
        ..comments.addAll(_generateHeader(node))
        ..directives.addAll(_generateImports())
        ..body.addAll([
          _generateWidgetClass(node, className),
        ]),
    );

    final code = library.accept(_emitter).toString();
    return _formatter.format(code);
  }

  List<String> _generateHeader(AstNode node) {
    final componentName = node.className.replaceAll('Meta', '').toLowerCase();
    return [
      '============================================',
      'GENERATED BY FORGE v$version',
      'DO NOT MODIFY - Regenerated on build',
      'Source: meta/${componentName}.meta.dart',
      'Generated: ${DateTime.now().toIso8601String()}',
      '============================================',
    ];
  }

  Iterable<Directive> _generateImports() {
    return [
      Directive.import('package:flutter/material.dart'),
      Directive.import('../theme/app_theme.dart'),
    ];
  }

  Class _generateWidgetClass(AstNode node, String className) {
    final componentName = node.className.replaceAll('Meta', '').toLowerCase();

    return Class(
      (b) => b
        ..name = className
        ..extend = refer('StatelessWidget')
        ..fields.addAll(_generateFields(node))
        ..constructors.add(_generateConstructor(node, className))
        ..methods.add(_generateBuildMethod(node, componentName)),
    );
  }

  Iterable<Field> _generateFields(AstNode node) {
    final fields = <Field>[];

    for (final prop in node.properties) {
      // Determine the type - don't add ? if already nullable
      final typeStr = prop.isRequired
          ? prop.type
          : prop.type.endsWith('?')
              ? prop.type
              : '${prop.type}?';

      fields.add(Field(
        (b) => b
          ..name = prop.name
          ..modifier = FieldModifier.final$
          ..type = refer(typeStr),
      ));
    }

    return fields;
  }

  Constructor _generateConstructor(AstNode node, String className) {
    final params = <Parameter>[];

    // Add key parameter
    params.add(Parameter(
      (b) => b
        ..named = true
        ..name = 'super.key',
    ));

    // Add component fields
    for (final prop in node.properties) {
      params.add(Parameter(
        (b) => b
          ..named = true
          ..required = prop.isRequired
          ..toThis = true
          ..name = prop.name
          ..defaultTo =
              prop.defaultValue != null ? Code(prop.defaultValue!) : null,
      ));
    }

    return Constructor(
      (b) => b
        ..constant = true
        ..optionalParameters.addAll(params),
    );
  }

  Method _generateBuildMethod(AstNode node, String componentName) {
    // Generate code matching technical_specs.md pattern:
    // final tokens = AppTheme.of(context).button;
    final body = '''
      final tokens = AppTheme.of(context).$componentName;
      
      return GestureDetector(
        onTap: ${_hasProp(node, 'isDisabled') ? 'isDisabled ? null : onPressed' : 'onPressed'},
        child: Container(
          padding: tokens.padding,
          decoration: BoxDecoration(
            color: ${_hasProp(node, 'isDisabled') ? 'isDisabled ? tokens.bgColor.withOpacity(0.5) : tokens.bgColor' : 'tokens.bgColor'},
            borderRadius: BorderRadius.circular(tokens.radius),
            border: tokens.borderWidth > 0
                ? Border.all(
                    color: tokens.borderColor ?? Colors.black,
                    width: tokens.borderWidth,
                  )
                : null,
          ),
          child: ${_generateChildContent(node)},
        ),
      );
    ''';

    return Method(
      (b) => b
        ..annotations.add(refer('override'))
        ..name = 'build'
        ..returns = refer('Widget')
        ..requiredParameters.add(Parameter(
          (p) => p
            ..name = 'context'
            ..type = refer('BuildContext'),
        ))
        ..body = Code(body),
    );
  }

  bool _hasProp(AstNode node, String propName) {
    return node.properties.any((p) => p.name == propName);
  }

  String _generateChildContent(AstNode node) {
    if (_hasProp(node, 'isLoading')) {
      return '''
isLoading
            ? const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(
                  strokeWidth: 2,
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                ),
              )
            : Text(
                label,
                style: TextStyle(
                  color: tokens.textColor,
                  fontWeight: FontWeight.bold,
                ),
              )''';
    } else {
      return '''
Text(
                label,
                style: TextStyle(
                  color: tokens.textColor,
                  fontWeight: FontWeight.bold,
                ),
              )''';
    }
  }
}
