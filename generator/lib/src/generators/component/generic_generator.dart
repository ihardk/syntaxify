import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import 'package:forge/src/core/interfaces/component_generator.dart';
import 'package:forge/src/models/meta_component.dart';
import 'package:forge/src/models/token_definition.dart';

/// Fallback generator for components without a specific generator.
///
/// Produces a basic widget structure that can be customized.
class GenericGenerator implements ComponentGenerator {
  GenericGenerator({
    this.version = '0.1.0',
  });

  final String version;
  final _formatter = DartFormatter();
  final _emitter = DartEmitter(useNullSafetySyntax: true);

  @override
  String get componentType => 'generic';

  @override
  bool canHandle(MetaComponent component) => true; // Handles everything

  @override
  String generate({
    required MetaComponent component,
    TokenDefinition? tokens,
  }) {
    final componentName = component.className.replaceAll('Meta', '');
    final className = 'App$componentName';
    final tokenName = componentName.toLowerCase();

    final library = Library(
      (b) => b
        ..comments.addAll(_generateHeader(componentName))
        ..directives.addAll(_generateImports())
        ..body.add(_generateWidgetClass(component, className, tokenName)),
    );

    final code = library.accept(_emitter).toString();
    return _formatter.format(code);
  }

  List<String> _generateHeader(String componentName) {
    return [
      '============================================',
      'GENERATED BY FORGE v$version',
      'DO NOT MODIFY - Regenerated on build',
      'Component: $componentName',
      'Generated: ${DateTime.now().toIso8601String()}',
      '============================================',
    ];
  }

  Iterable<Directive> _generateImports() {
    return [
      Directive.import('package:flutter/material.dart'),
      Directive.import('../theme/app_theme.dart'),
    ];
  }

  Class _generateWidgetClass(
    MetaComponent component,
    String className,
    String tokenName,
  ) {
    return Class(
      (b) => b
        ..name = className
        ..docs.add('/// Generated $className component.')
        ..extend = refer('StatelessWidget')
        ..fields.addAll(_generateFields(component))
        ..constructors.add(_generateConstructor(component))
        ..methods.add(_generateBuildMethod(component, tokenName)),
    );
  }

  Iterable<Field> _generateFields(MetaComponent component) {
    final fields = <Field>[];

    for (final field in component.fields) {
      final typeStr = field.isRequired
          ? field.type
          : field.type.endsWith('?')
              ? field.type
              : '${field.type}?';

      fields.add(Field(
        (b) => b
          ..name = field.name
          ..modifier = FieldModifier.final$
          ..type = refer(typeStr),
      ));
    }

    return fields;
  }

  Constructor _generateConstructor(MetaComponent component) {
    final params = <Parameter>[];

    params.add(Parameter(
      (b) => b
        ..named = true
        ..name = 'super.key',
    ));

    for (final field in component.fields) {
      params.add(Parameter(
        (b) => b
          ..named = true
          ..required = field.isRequired
          ..toThis = true
          ..name = field.name
          ..defaultTo =
              field.defaultValue != null ? Code(field.defaultValue!) : null,
      ));
    }

    return Constructor(
      (b) => b
        ..constant = true
        ..optionalParameters.addAll(params),
    );
  }

  Method _generateBuildMethod(MetaComponent component, String tokenName) {
    final body = '''
      final tokens = AppTheme.of(context).$tokenName;
      
      return Container(
        padding: tokens.padding,
        decoration: BoxDecoration(
          color: tokens.bgColor,
          borderRadius: BorderRadius.circular(tokens.radius),
        ),
        child: const Text('$tokenName component'),
      );
    ''';

    return Method(
      (b) => b
        ..annotations.add(refer('override'))
        ..name = 'build'
        ..returns = refer('Widget')
        ..requiredParameters.add(Parameter(
          (p) => p
            ..name = 'context'
            ..type = refer('BuildContext'),
        ))
        ..body = Code(body),
    );
  }
}
