import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import 'package:syntaxify/src/core/interfaces/component_generator.dart';
import 'package:syntaxify/src/models/component_definition.dart';
import 'package:syntaxify/src/models/token_definition.dart';

/// Text-specific generator with renderer pattern.
///
/// Generates AppText widget that:
/// - Defines WHAT (text content, variant)
/// - Delegates HOW to DesignStyle.renderText()
class TextGenerator implements ComponentGenerator {
  TextGenerator({
    this.version = '0.1.0',
  });

  final String version;
  final _formatter =
      DartFormatter(languageVersion: DartFormatter.latestLanguageVersion);
  final _emitter = DartEmitter(useNullSafetySyntax: true);

  @override
  String get componentType => 'text';

  @override
  bool canHandle(ComponentDefinition component) {
    final componentName =
        component.className.replaceAll('Meta', '').toLowerCase();
    return componentName == componentType;
  }

  String _getComponentType(ComponentDefinition component) {
    final name =
        component.explicitName ?? component.className.replaceAll('Meta', '');
    // Strip 'App' prefix if present
    final withoutApp = name.startsWith('App') ? name.substring(3) : name;
    return withoutApp.toLowerCase();
  }

  @override
  String generate({
    required ComponentDefinition component,
    TokenDefinition? tokens,
  }) {
    final library = Library(
      (b) => b
        ..comments.addAll(_generateHeader(component))
        ..directives.addAll(_generateImports())
        ..body.addAll([
          _generateTextClass(component),
        ]),
    );

    final code = library.accept(_emitter).toString();
    return _formatter.format(code);
  }

  List<String> _generateHeader(ComponentDefinition component) {
    return [
      '============================================',
      'GENERATED BY SYNTAXIFY v$version',
      'DO NOT MODIFY - Regenerated on build',
      'Component: Text (Renderer Pattern)',
      'Generated: ${DateTime.now().toIso8601String()}',
      '============================================',
    ];
  }

  Iterable<Directive> _generateImports() {
    return [
      Directive.import('package:flutter/material.dart'),
      Directive.import('../../design_system/design_system.dart'),
    ];
  }

  Class _generateTextClass(ComponentDefinition component) {
    return Class(
      (b) => b
        ..docs.add('/// A customizable text component.')
        ..docs.add('///')
        ..docs.add('/// Uses the renderer pattern: WHAT is defined here,')
        ..docs.add('/// HOW is delegated to [DesignStyle.renderText].')
        ..docs.add('///')
        ..docs.add('/// Usage:')
        ..docs.add('/// ```dart')
        ..docs.add(
            "/// AppText(text: 'Hello', variant: TextVariant.headlineMedium)")
        ..docs.add('/// ```')
        ..name = 'AppText'
        ..extend = refer('StatelessWidget')
        ..fields.addAll(_generateFields(component))
        ..constructors.add(_generateConstructor(component))
        ..methods.add(_generateBuildMethod()),
    );
  }

  Iterable<Field> _generateFields(ComponentDefinition component) {
    return [
      Field(
        (b) => b
          ..docs.add('/// The text content to display.')
          ..name = 'text'
          ..type = refer('String')
          ..modifier = FieldModifier.final$,
      ),
      Field(
        (b) => b
          ..docs
              .add('/// The text variant (displayLarge, headlineMedium, etc).')
          ..name = 'variant'
          ..type = refer('TextVariant?')
          ..modifier = FieldModifier.final$,
      ),
      Field(
        (b) => b
          ..docs.add('/// Text alignment.')
          ..name = 'align'
          ..type = refer('TextAlign?')
          ..modifier = FieldModifier.final$,
      ),
      Field(
        (b) => b
          ..docs.add('/// Maximum number of lines.')
          ..name = 'maxLines'
          ..type = refer('int?')
          ..modifier = FieldModifier.final$,
      ),
      Field(
        (b) => b
          ..docs.add('/// Text overflow behavior.')
          ..name = 'overflow'
          ..type = refer('TextOverflow?')
          ..modifier = FieldModifier.final$,
      ),
    ];
  }

  Constructor _generateConstructor(ComponentDefinition component) {
    return Constructor(
      (c) => c
        ..constant = true
        ..optionalParameters.addAll([
          Parameter((p) => p
            ..name = 'super.key'
            ..named = true),
          Parameter((p) => p
            ..name = 'text'
            ..named = true
            ..required = true
            ..toThis = true),
          Parameter((p) => p
            ..name = 'variant'
            ..named = true
            ..toThis = true),
          Parameter((p) => p
            ..name = 'align'
            ..named = true
            ..toThis = true),
          Parameter((p) => p
            ..name = 'maxLines'
            ..named = true
            ..toThis = true),
          Parameter((p) => p
            ..name = 'overflow'
            ..named = true
            ..toThis = true),
        ]),
    );
  }

  Method _generateBuildMethod() {
    return Method(
      (m) => m
        ..annotations.add(refer('override'))
        ..name = 'build'
        ..returns = refer('Widget')
        ..requiredParameters.add(Parameter(
          (p) => p
            ..name = 'context'
            ..type = refer('BuildContext'),
        ))
        ..body = const Code('''
// Delegate to style's renderer (HOW)
return AppTheme.of(context).style.renderText(
  text: text,
  variant: variant,
  align: align,
  maxLines: maxLines,
  overflow: overflow,
);
'''),
    );
  }
}
