import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';

import 'package:syntaxify/src/core/interfaces/component_generator.dart';
import 'package:syntaxify/src/models/component_definition.dart';
import 'package:syntaxify/src/models/token_definition.dart';

/// Meta-driven component generator.
///
/// This is the ONE generator that handles ALL components by reading
/// properties from the .meta.dart definition and generating a widget
/// that delegates rendering to DesignStyle.render{ComponentName}().
///
/// Example: If you define CheckboxMeta with properties [value, onChanged],
/// this generator produces AppCheckbox that calls style.renderCheckbox().
class ComponentGenerator implements IComponentGenerator {
  ComponentGenerator({
    this.version = '0.1.0',
    this.variantEnums = const {},
  });

  final String version;

  /// Map of variant enum names to their values.
  /// Parsed dynamically from user's design system files.
  /// e.g., {'ButtonVariant': ['primary', 'secondary', 'outlined', 'text']}
  final Map<String, List<String>> variantEnums;

  final _formatter =
      DartFormatter(languageVersion: DartFormatter.latestLanguageVersion);
  final _emitter = DartEmitter(useNullSafetySyntax: true);

  @override
  String get componentType => 'component';

  @override
  bool canHandle(ComponentDefinition component) => true;

  @override
  String generate({
    required ComponentDefinition component,
    TokenDefinition? tokens,
  }) {
    // Derive names from meta class
    // e.g., CheckboxMeta -> Checkbox, AppCheckbox, renderCheckbox
    final baseName = _getBaseName(component);
    final className = 'App$baseName';
    final renderMethodName = 'render$baseName';

    final library = Library(
      (b) => b
        ..comments.addAll(_generateHeader(className))
        ..directives.addAll(_generateImports())
        ..body.add(_generateWidgetClass(
          component,
          className,
          renderMethodName,
        )),
    );

    final code = library.accept(_emitter).toString();
    return _formatter.format(code);
  }

  /// Extract base name from component definition.
  /// ButtonMeta -> Button, AppButtonMeta -> Button, etc.
  String _getBaseName(ComponentDefinition component) {
    final name =
        component.explicitName ?? component.className.replaceAll('Meta', '');
    // Strip 'App' prefix if present
    final base = name.startsWith('App') ? name.substring(3) : name;
    if (base.isEmpty) {
      throw Exception('Component name cannot be empty');
    }
    return base;
  }

  List<String> _generateHeader(String className) {
    return [
      '============================================',
      'GENERATED BY SYNTAXIFY v$version',
      'DO NOT MODIFY - Regenerated on build',
      'Component: $className (Meta-Driven)',
      'Generated: ${DateTime.now().toIso8601String()}',
      '============================================',
    ];
  }

  Iterable<Directive> _generateImports() {
    return [
      Directive.import('package:flutter/material.dart'),
      Directive.import('../../design_system/design_system.dart'),
    ];
  }

  Class _generateWidgetClass(
    ComponentDefinition component,
    String className,
    String renderMethodName,
  ) {
    final baseName = _getBaseName(component);

    return Class(
      (b) {
        b
          ..name = className
          ..docs.addAll([
            '/// A design-system-aware $baseName component.',
            '///',
            '/// This widget delegates rendering to [DesignStyle.$renderMethodName].',
            '/// Properties are defined in the corresponding .meta.dart file.',
          ])
          ..extend = refer('StatelessWidget')
          ..fields.addAll(_generateFields(component))
          ..constructors.add(_generateConstructor(component))
          ..constructors.addAll(_generateVariantConstructors(component))
          ..methods.add(_generateBuildMethod(component, renderMethodName));

        // Add type parameters if the component is generic
        if (component.typeParameters.isNotEmpty) {
          b.types.addAll(
            component.typeParameters.map((t) => refer(t)),
          );
        }
      },
    );
  }

  /// Generate convenience constructors for variant properties.
  /// e.g., AppButton.primary(), AppButton.secondary()
  Iterable<Constructor> _generateVariantConstructors(
      ComponentDefinition component) {
    final constructors = <Constructor>[];

    // Find variant properties (types ending with 'Variant' or 'Variant?')
    for (final prop in component.properties) {
      // Strip nullable suffix for matching
      final baseType = prop.type.replaceAll('?', '');
      if (!baseType.endsWith('Variant')) continue;

      // Get variant enum name (e.g., ButtonVariant, TextVariant)
      final variantType = baseType;
      // Get variant values from the component definition
      final variantValues = _getVariantValues(variantType);

      for (final variantValue in variantValues) {
        constructors.add(_generateVariantConstructor(
          component,
          prop,
          variantType,
          variantValue,
        ));
      }
    }

    return constructors;
  }

  /// Get variant values for a variant type from the parsed design system enums.
  ///
  /// Returns values from the user's design system, or empty list if not found.
  List<String> _getVariantValues(String variantType) {
    return variantEnums[variantType] ?? [];
  }

  /// Generate a single variant convenience constructor.
  Constructor _generateVariantConstructor(
    ComponentDefinition component,
    ComponentProp variantProp,
    String variantType,
    String variantValue,
  ) {
    final params = <Parameter>[];

    // Add key parameter
    params.add(Parameter(
      (b) => b
        ..named = true
        ..name = 'super.key',
    ));

    // Add all properties except the variant (which is set by the constructor)
    for (final prop in component.properties) {
      if (prop.name == variantProp.name) continue; // Skip variant prop

      params.add(Parameter(
        (b) => b
          ..named = true
          ..required = prop.isRequired
          ..toThis = true
          ..name = prop.name
          ..defaultTo =
              prop.defaultValue != null ? _getDefaultValueCode(prop) : null,
      ));
    }

    return Constructor(
      (b) => b
        ..name = variantValue
        ..constant = true
        ..docs.add(
            '/// Creates a $variantValue ${_getBaseName(component).toLowerCase()}.')
        ..optionalParameters.addAll(params)
        ..initializers
            .add(Code('${variantProp.name} = $variantType.$variantValue')),
    );
  }

  Iterable<Field> _generateFields(ComponentDefinition component) {
    final fields = <Field>[];

    for (final prop in component.properties) {
      // Determine type string
      // Properties with default values keep their non-nullable type
      // Properties without defaults that are optional become nullable
      String typeStr = prop.type;
      final hasDefault = prop.defaultValue != null;
      if (!prop.isRequired && !hasDefault && !typeStr.endsWith('?')) {
        typeStr = '$typeStr?';
      }

      fields.add(Field(
        (b) => b
          ..docs.add('/// ${prop.description ?? prop.name}')
          ..name = prop.name
          ..modifier = FieldModifier.final$
          ..type = refer(typeStr),
      ));
    }

    return fields;
  }

  Constructor _generateConstructor(ComponentDefinition component) {
    final params = <Parameter>[];

    // Always add key parameter
    params.add(Parameter(
      (b) => b
        ..named = true
        ..name = 'super.key',
    ));

    // Add all properties from meta
    for (final prop in component.properties) {
      params.add(Parameter(
        (b) => b
          ..named = true
          ..required = prop.isRequired
          ..toThis = true
          ..name = prop.name
          ..defaultTo =
              prop.defaultValue != null ? _getDefaultValueCode(prop) : null,
      ));
    }

    return Constructor(
      (b) => b
        ..constant = true
        ..optionalParameters.addAll(params),
    );
  }

  Method _generateBuildMethod(
    ComponentDefinition component,
    String renderMethodName,
  ) {
    // Build the render method call with all properties
    final args = component.properties
        .map((prop) => '${prop.name}: ${prop.name}')
        .join(',\n      ');

    final body = '''
return AppTheme.of(context).style.$renderMethodName(
      $args
    );
''';

    return Method(
      (b) => b
        ..annotations.add(refer('override'))
        ..name = 'build'
        ..returns = refer('Widget')
        ..requiredParameters.add(Parameter(
          (p) => p
            ..name = 'context'
            ..type = refer('BuildContext'),
        ))
        ..body = Code(body),
    );
  }

  Code _getDefaultValueCode(ComponentProp prop) {
    final defaultValue = prop.defaultValue!;

    // If the type is an enum (present in variantEnums), ensure prefix
    // But check if already prefixed to avoid double-prefixing
    if (variantEnums.containsKey(prop.type)) {
      // If already has the full prefix, use as-is
      if (defaultValue.contains('.')) {
        return Code(defaultValue);
      }
      // Otherwise add the prefix: e.g. 'primary' -> 'ButtonVariant.primary'
      return Code('${prop.type}.$defaultValue');
    }
    // Otherwise return raw value (bools, numbers)
    return Code(defaultValue);
  }
}
