import 'dart:io';
import 'package:path/path.dart' as path;

/// Auto-generates integration files from discovered components
class IntegrationGenerator {
  final String projectRoot;
  final List<ComponentInfo> components;

  IntegrationGenerator(this.projectRoot, this.components);

  /// Generate all integration files
  void generateAll() {
    _generateDesignSystem();
    _generateDesignStyle();
    _generateMaterialStyle();
    _generateCupertinoStyle();
    _generateNeoStyle();

    print('âœ… Generated 5 integration files');
  }

  /// Generate design_system.generated.dart
  void _generateDesignSystem() {
    final buffer = StringBuffer();

    buffer.writeln('/// AUTO-GENERATED - DO NOT EDIT');
    buffer.writeln('/// Generated by IntegrationGenerator');
    buffer.writeln('/// To regenerate: dart run tool/integration_generator.dart');
    buffer.writeln('library design_system;');
    buffer.writeln();
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln("import 'package:flutter/cupertino.dart';");
    buffer.writeln("import 'package:syntaxify/syntaxify.dart';");
    buffer.writeln();

    // Import foundation
    buffer.writeln('// Foundation tokens');
    buffer.writeln("import 'tokens/foundation/foundation_tokens.dart';");
    buffer.writeln();

    // Import all tokens
    buffer.writeln('// Component tokens');
    for (final component in components) {
      buffer.writeln("import 'tokens/${component.name}_tokens.dart';");
    }
    buffer.writeln();

    // Import variants
    buffer.writeln('// Variants');
    for (final component in components.where((c) => c.hasVariant)) {
      buffer.writeln("import 'variants/${component.name}_variant.dart';");
    }
    buffer.writeln();

    // Import models
    final modelsExist = components.where((c) => c.hasModel);
    if (modelsExist.isNotEmpty) {
      buffer.writeln('// Models');
      for (final component in modelsExist) {
        buffer.writeln("import 'models/${component.name}_item.dart';");
      }
      buffer.writeln();
    }

    buffer.writeln("import 'app_icons.dart';");
    buffer.writeln();

    // Export all tokens
    buffer.writeln('// Export tokens');
    buffer.writeln("export 'tokens/foundation/foundation_tokens.dart';");
    for (final component in components) {
      buffer.writeln("export 'tokens/${component.name}_tokens.dart';");
    }
    buffer.writeln();

    // Export variants
    buffer.writeln('// Export variants');
    for (final component in components.where((c) => c.hasVariant)) {
      buffer.writeln("export 'variants/${component.name}_variant.dart';");
    }
    buffer.writeln();

    // Export models
    if (modelsExist.isNotEmpty) {
      buffer.writeln('// Export models');
      for (final component in modelsExist) {
        buffer.writeln("export 'models/${component.name}_item.dart';");
      }
      buffer.writeln();
    }

    buffer.writeln("export 'app_icons.dart';");
    buffer.writeln();

    // Part files
    buffer.writeln('// Part files');
    buffer.writeln("part 'app_theme.dart';");
    buffer.writeln("part 'design_style.dart';");
    buffer.writeln();

    // Foundation parts
    buffer.writeln('// Foundation tokens');
    buffer.writeln("part 'tokens/foundation/material_foundation.dart';");
    buffer.writeln("part 'tokens/foundation/cupertino_foundation.dart';");
    buffer.writeln("part 'tokens/foundation/neo_foundation.dart';");
    buffer.writeln();

    // Style parts
    buffer.writeln('// Styles');
    buffer.writeln("part 'styles/material_style.dart';");
    buffer.writeln("part 'styles/cupertino_style.dart';");
    buffer.writeln("part 'styles/neo_style.dart';");
    buffer.writeln();

    // Renderer parts
    buffer.writeln('// Component renderers');
    for (final component in components) {
      if (component.name == 'icon') {
        // Special case: icon uses shared renderer
        buffer.writeln("part 'components/icon/icon_renderer.dart';");
      } else {
        buffer.writeln("part 'components/${component.name}/material_renderer.dart';");
        buffer.writeln("part 'components/${component.name}/cupertino_renderer.dart';");
        buffer.writeln("part 'components/${component.name}/neo_renderer.dart';");
      }
      buffer.writeln();
    }

    _writeFile('design_system/design_system.generated.dart', buffer.toString());
  }

  /// Generate design_style.generated.dart
  void _generateDesignStyle() {
    final buffer = StringBuffer();

    buffer.writeln('/// AUTO-GENERATED - DO NOT EDIT');
    buffer.writeln('part of design_system;');
    buffer.writeln();
    buffer.writeln('/// Design system contract.');
    buffer.writeln('/// All styles must implement this sealed class.');
    buffer.writeln('sealed class DesignStyle {');
    buffer.writeln('  const DesignStyle();');
    buffer.writeln();
    buffer.writeln('  /// Foundation tokens for this style');
    buffer.writeln('  FoundationTokens get foundation;');
    buffer.writeln();

    // Generate token methods and render methods for each component
    for (final component in components) {
      final className = _toPascalCase(component.name);
      final methodName = _toCamelCase(component.name);

      // Token method (if has variant)
      if (component.hasVariant) {
        final variantClass = '${className}Variant';
        buffer.writeln('  /// Get tokens for ${component.name} component');
        buffer.writeln('  ${className}Tokens ${methodName}Tokens($variantClass variant);');
        buffer.writeln();
      } else {
        buffer.writeln('  /// Get tokens for ${component.name} component');
        buffer.writeln('  ${className}Tokens get ${methodName}Tokens;');
        buffer.writeln();
      }

      // Render method
      buffer.writeln('  /// Render ${component.name} component');
      if (component.name == 'app_bar') {
        buffer.writeln('  PreferredSizeWidget render${className}({');
      } else {
        buffer.writeln('  Widget render${className}({');
      }
      buffer.writeln('    // TODO: Add parameters from meta file');
      buffer.writeln('  });');
      buffer.writeln();
    }

    buffer.writeln('}');

    _writeFile('design_system/design_style.generated.dart', buffer.toString());
  }

  /// Generate material_style.generated.dart
  void _generateMaterialStyle() {
    _generateStyleFile('material', 'Material');
  }

  /// Generate cupertino_style.generated.dart
  void _generateCupertinoStyle() {
    _generateStyleFile('cupertino', 'Cupertino');
  }

  /// Generate neo_style.generated.dart
  void _generateNeoStyle() {
    _generateStyleFile('neo', 'Neo');
  }

  void _generateStyleFile(String styleName, String styleClass) {
    final buffer = StringBuffer();

    buffer.writeln('/// AUTO-GENERATED - DO NOT EDIT');
    buffer.writeln('part of design_system;');
    buffer.writeln();
    buffer.writeln('/// ${styleClass} design system implementation');
    buffer.writeln('class ${styleClass}Style extends DesignStyle');
    buffer.writeln('    with');

    // Add all renderer mixins
    final mixins = <String>[];
    for (final component in components) {
      if (component.name == 'icon') {
        // Icon uses shared renderer
        mixins.add('        IconRenderer');
      } else {
        final className = _toPascalCase(component.name);
        mixins.add('        ${styleClass}${className}Renderer');
      }
    }

    buffer.writeln(mixins.join(',\n'));
    buffer.writeln(' {');
    buffer.writeln('  const ${styleClass}Style();');
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.writeln('  FoundationTokens get foundation => ${styleName}Foundation;');
    buffer.writeln('}');

    _writeFile('design_system/styles/${styleName}_style.generated.dart', buffer.toString());
  }

  /// Helper: Write file
  void _writeFile(String relativePath, String content) {
    final file = File(path.join(projectRoot, relativePath));
    file.parent.createSync(recursive: true);
    file.writeAsStringSync(content);
    print('Generated: $relativePath');
  }

  /// Helper: Convert to PascalCase
  String _toPascalCase(String snakeCase) {
    return snakeCase
        .split('_')
        .map((word) => word[0].toUpperCase() + word.substring(1))
        .join('');
  }

  /// Helper: Convert to camelCase
  String _toCamelCase(String snakeCase) {
    final words = snakeCase.split('_');
    return words[0] + words.skip(1).map((w) => w[0].toUpperCase() + w.substring(1)).join('');
  }
}

/// Component information
class ComponentInfo {
  final String name;
  final bool hasVariant;
  final bool hasModel;

  ComponentInfo({
    required this.name,
    required this.hasVariant,
    required this.hasModel,
  });
}

/// Scan for components and generate integration files
void main() {
  final projectRoot = '/home/user/syntaxify/generator';

  // Discover components
  final metaDir = Directory(path.join(projectRoot, 'meta'));
  final components = <ComponentInfo>[];

  for (final file in metaDir.listSync().whereType<File>()) {
    if (!file.path.endsWith('.meta.dart')) continue;

    final fileName = path.basename(file.path);
    final name = fileName.replaceAll('.meta.dart', '');

    // Check for variant
    final hasVariant = File(path.join(
      projectRoot, 'design_system/variants/${name}_variant.dart'
    )).existsSync();

    // Check for model
    final hasModel = File(path.join(
      projectRoot, 'design_system/models/${name}_item.dart'
    )).existsSync();

    components.add(ComponentInfo(
      name: name,
      hasVariant: hasVariant,
      hasModel: hasModel,
    ));
  }

  print('Found ${components.length} components');

  // Generate integration files
  final generator = IntegrationGenerator(projectRoot, components);
  generator.generateAll();
}
